<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Messenger Aijamal</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
</head>
<body>
{% if session.get('user_id') %}
<div class="container">
  <div class="sidebar">
    <form action="{{ url_for('logout') }}" method="GET">
      <button type="submit">Logout</button>
    </form>
    <h2>Users</h2>
    <ul id="users" class="user-list">
      {% for user in users %}
      <li class="user-item" data-id="{{ user[0] }}">
        <strong>{{ user[1] }}</strong><br>
        <small>{{ user[2] }}</small>
        <button class="call-user-btn">ðŸ“ž</button>
      </li>
      {% endfor %}
    </ul>
  </div>
  <div class="chat">
    <div class="chat-header">
      <h3 id="chat-with">Select a user</h3>
    </div>
    <div id="chat-box" class="chat-box"></div>
    <div class="chat-controls">
      <input type="text" id="messageInput" placeholder="Enter a message">
      <button onclick="sendMessage()">âž¤</button>
    </div>
  </div>
</div>

<script>
  const socket = io();
  const ICE_SERVERS = [{ urls: 'stun:stun.l.google.com:19302' }];

  let currentChatUserId = null;
  const peerConnections = new Map();
  const pendingCandidates = {};

  socket.on('connect', () => {
    console.log('Socket connected:', socket.id);
    socket.emit('register', { user_id: {{ session["user_id"] }} });
  });

  document.addEventListener('DOMContentLoaded', () => {
    // 1) ÐŸÑ€Ð¸Ð²ÑÐ·Ñ‹Ð²Ð°ÐµÐ¼ ÐºÐ»Ð¸ÐºÐ¸ Ð¿Ð¾ ÑÐ¿Ð¸ÑÐºÑƒ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÐµÐ¹
    document.querySelectorAll('.user-item').forEach(item => {
      const btn = item.querySelector('.call-user-btn');
      const uid = item.dataset.id;
      // Ð—Ð°Ð¿Ñ€ÐµÑ‚ Ð·Ð²Ð¾Ð½Ð¸Ñ‚ÑŒ ÑÐµÐ±Ðµ
      if (uid === '{{ session["user_id"] }}') {
        btn.disabled = true;
        return;
      }
      btn.addEventListener('click', e => {
        e.stopPropagation();
        startCall(uid);
      });
    });

    // 2) Ð¡Ð¸Ð³Ð½Ð°Ð»ÑŒÐ½Ñ‹Ðµ ÑÐ¾Ð±Ñ‹Ñ‚Ð¸Ñ
    socket.on('call-made', async data => {
      console.log('â† received call-made', data);
      try {
        await handleIncomingCall(data.from, data.offer);
      } catch (err) {
        console.error('âœ– Error in handleIncomingCall:', err);
      }
    });

    socket.on('answer-made', data => {
      console.log('â† received answer-made', data);
      const pc = peerConnections.get(data.from);
      if (pc) {
        pc.setRemoteDescription(new RTCSessionDescription(data.answer))
          .then(() => console.log('   Â· setRemoteDescription(answer)'))
          .catch(e => console.error(e));
      }
    });

    socket.on('ice-candidate', data => {
      console.log('â† received ice-candidate', data);
      const pc = peerConnections.get(data.from);
      if (pc) {
        pc.addIceCandidate(new RTCIceCandidate(data.candidate))
          .then(() => console.log('   Â· added ICE candidate'))
          .catch(e => console.error(e));
      } else {
        pendingCandidates[data.from] = pendingCandidates[data.from] || [];
        pendingCandidates[data.from].push(data.candidate);
      }
    });
  }); // â† Ð½Ðµ Ð·Ð°Ð±ÑƒÐ´ÑŒÑ‚Ðµ Ð·Ð°ÐºÑ€Ñ‹Ñ‚ÑŒ DOMContentLoaded

  // 3) Ð¤ÑƒÐ½ÐºÑ†Ð¸Ð¸ Ð²Ð½Ðµ DOMContentLoaded
  async function startCall(targetId) {
    console.log('â†’ startCall to', targetId);
    const localStream = await getLocalStream();
    const pc = createPeerConnection(targetId, localStream);
    peerConnections.set(targetId, pc);

    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    socket.emit('call-user', { to: targetId, offer });
    console.log('â†’ emitted call-user');
  }

  async function handleIncomingCall(fromId, offer) {
    console.log('â†’ handleIncomingCall from', fromId);
    const localStream = await getLocalStream();
    const pc = createPeerConnection(fromId, localStream);
    peerConnections.set(fromId, pc);

    await pc.setRemoteDescription(new RTCSessionDescription(offer));
    (pendingCandidates[fromId] || []).forEach(async cand => {
      await pc.addIceCandidate(new RTCIceCandidate(cand));
    });
    delete pendingCandidates[fromId];

    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);
    socket.emit('make-answer', { to: fromId, answer });
    console.log('â†’ emitted make-answer');
  }

  // ÐžÐ±ÑŠÐµÐ´Ð¸Ð½Ñ‘Ð½Ð½Ñ‹Ð¹ Ñ„Ð°Ð±Ñ€Ð¸Ñ‡Ð½Ñ‹Ð¹ Ð¼ÐµÑ‚Ð¾Ð´
  function createPeerConnection(peerId, stream) {
    const pc = new RTCPeerConnection({ iceServers: ICE_SERVERS });
    stream.getTracks().forEach(track => pc.addTrack(track, stream));

    pc.onicecandidate = e => {
      if (e.candidate) {
        socket.emit('ice-candidate', { to: peerId, candidate: e.candidate });
      }
    };

    pc.ontrack = e => {
      attachRemoteStream(e.streams[0]);
    };

    attachLocalStream(stream);
    return pc;
  }

  async function getLocalStream() {
    try {
      return await navigator.mediaDevices.getUserMedia({ audio: true });
    } catch (e) {
      console.error('Error accessing media devices.', e);
      throw e;
    }
  }

  function attachLocalStream(stream) {
    let audio = document.getElementById('localAudio');
    if (!audio) {
      audio = document.createElement('audio');
      audio.id = 'localAudio';
      audio.autoplay = true;
      audio.muted = true;
      document.body.appendChild(audio);
    }
    audio.srcObject = stream;
  }

  function attachRemoteStream(stream) {
    let audio = document.getElementById('remoteAudio');
    if (!audio) {
      audio = document.createElement('audio');
      audio.id = 'remoteAudio';
      audio.autoplay = true;
      document.body.appendChild(audio);
    }
    audio.srcObject = stream;
  }
</script>


<audio id="localAudio" autoplay muted></audio>
<audio id="remoteAudio" autoplay></audio>
{% endif %}
</body>
</html>
