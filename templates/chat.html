<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Messenger Aijamal</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
</head>
<body>
  {% if session.get('user_id') %}

    <div class="container">
      <div class="sidebar">
        <form action="{{ url_for('logout') }}" method="GET" style="margin: 0;">
          <button type="submit" style="cursor: pointer;">Logout</button>
        </form>
        <h2>Users</h2>
        <ul id="users" class="user-list">
          {% for user in users %}
            <li class="user-item" data-id="{{ user[0] }}" data-phone="{{ user[2] }}" style="cursor:pointer;">
              <strong>{{ user[1] }}</strong><br>
              <small>{{ user[2] }}</small>
              <button class="call-user-btn" style="margin-left:10px;">üìû</button>
            </li>
          {% endfor %}
        </ul>
      </div>

      <div class="chat">
        <div class="chat-header">
          <h3 id="chat-with">Select a user</h3>
        </div>
        <div id="chat-box" class="chat-box"></div>
        <div class="chat-controls">
          <input type="text" id="messageInput" placeholder="Enter a message">
          <button onclick="sendMessage()">‚û§</button>
        </div>
      </div>
    </div>

    <!-- –ü–æ–¥–∫–ª—é—á–∞–µ–º Socket.IO –∏ –∑–∞–ø—É—Å–∫–∞–µ–º —á–∞—Ç + WebRTC -->
    <script>
      const socket = io();
      socket.on('connect', () => {
        console.log('socket connected, id =', socket.id);
        // –≠–º–∏—Ç–∏–º "—Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é" —Å–æ —Å–≤–æ–∏–º user_id, —á—Ç–æ–±—ã —Å–µ—Ä–≤–µ—Ä –∑–Ω–∞–ª, –∫–æ–º—É –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å —Å–∏–≥–Ω–∞–ª—ã
        socket.emit('register', { user_id: {{ session["user_id"] }} });
      });
      // ICE‚Äë—Å–µ—Ä–≤–µ—Ä—ã –¥–ª—è WebRTC
      const ICE_SERVERS = [{ urls: 'stun:stun.l.google.com:19302' }];

      let currentChatUserId = null;
      let localStream, peerConnection;

      document.addEventListener('DOMContentLoaded', () => {
        const chatWithEl   = document.getElementById('chat-with');
        const chatBox      = document.getElementById('chat-box');
        const messageInput = document.getElementById('messageInput');

        // –í—ã–±–æ—Ä –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è —á–∞—Ç–∞
        document.querySelectorAll('.user-item').forEach(item => {
          item.addEventListener('click', e => {
            if (e.target.classList.contains('call-user-btn')) return;
            currentChatUserId = item.dataset.id;
            chatWithEl.textContent = `Chat with ${item.querySelector('strong').textContent}`;
            loadMessages(currentChatUserId);
          });
        });

        // –ó–∞–≥—Ä—É–∑–∫–∞ –∏—Å—Ç–æ—Ä–∏–∏
        function loadMessages(userId) {
          fetch(`/messages/${userId}`)
            .then(res => res.json())
            .then(msgs => {
              chatBox.innerHTML = '';
              msgs.forEach(m => {
                const div = document.createElement('div');
                div.className = m.from_me ? 'message me' : 'message you';
                div.textContent = m.from_me ? `You: ${m.message}` : m.message;
                chatBox.appendChild(div);
              });
              chatBox.scrollTop = chatBox.scrollHeight;
            });
        }

        // –û—Ç–ø—Ä–∞–≤–∫–∞ –Ω–æ–≤–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è
        window.sendMessage = () => {
          if (!currentChatUserId) return alert('–í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å–ª–µ–≤–∞');
          const text = messageInput.value.trim();
          if (!text) return;
          fetch('/send', {
            method: 'POST',
            headers: {'Content-Type':'application/json'},
            body: JSON.stringify({ to_user_id: currentChatUserId, message: text })
          })
          .then(() => {
            messageInput.value = '';
            loadMessages(currentChatUserId);
          });
        };

        // –ù–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏–∑ WebSocket
        socket.on('new_message', data => {
          if (+data.from_user_id === +currentChatUserId) {
            loadMessages(currentChatUserId);
          }
        });

        // –ö–Ω–æ–ø–∫–∏ ¬´üìû¬ª –¥–ª—è –∑–≤–æ–Ω–∫–æ–≤
        document.querySelectorAll('.call-user-btn').forEach(btn => {
          btn.addEventListener('click', e => {
            e.stopPropagation();
            const targetId = btn.closest('.user-item').dataset.id;
            if (targetId) startCall(targetId);
          });
        });

        // –°–æ–±—ã—Ç–∏—è —Å–∏–≥–Ω–∞–ª–∏–Ω–≥–∞
        socket.on('call-made', async data => {
          await handleIncomingCall(data.from, data.offer);
        });
        socket.on('answer-made', async data => {
          await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
        });
        socket.on('ice-candidate', data => {
          peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
        });
      });

      // –ò–Ω–∏—Ü–∏–∞—Ü–∏—è –∑–≤–æ–Ω–∫–∞
      async function startCall(targetId) {
        localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        attachLocalStream(localStream);

        peerConnection = new RTCPeerConnection({ iceServers: ICE_SERVERS });
        localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

        peerConnection.onicecandidate = e => {
          if (e.candidate) {
            socket.emit('ice-candidate', { to: targetId, candidate: e.candidate });
          }
        };
        peerConnection.ontrack = e => {
          attachRemoteStream(e.streams[0]);
        };

        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);
        socket.emit('call-user', { to: targetId, offer });
      }

      // –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—Ö–æ–¥—è—â–µ–≥–æ –∑–≤–æ–Ω–∫–∞
      async function handleIncomingCall(fromId, offer) {
        localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        attachLocalStream(localStream);

        peerConnection = new RTCPeerConnection({ iceServers: ICE_SERVERS });
        localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

        peerConnection.onicecandidate = e => {
          if (e.candidate) {
            socket.emit('ice-candidate', { to: fromId, candidate: e.candidate });
          }
        };
        peerConnection.ontrack = e => {
          attachRemoteStream(e.streams[0]);
        };

        await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);
        socket.emit('make-answer', { to: fromId, answer });
      }

      // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ: –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∞—É–¥–∏–æ–ø–æ—Ç–æ–∫–∏
      function attachLocalStream(stream) {
        let audioLocal = document.getElementById('localAudio');
        if (!audioLocal) {
          audioLocal = document.createElement('audio');
          audioLocal.id = 'localAudio';
          audioLocal.autoplay = true;
          audioLocal.muted = true;
          document.body.appendChild(audioLocal);
        }
        audioLocal.srcObject = stream;
      }
      function attachRemoteStream(stream) {
        let audioRemote = document.getElementById('remoteAudio');
        if (!audioRemote) {
          audioRemote = document.createElement('audio');
          audioRemote.id = 'remoteAudio';
          audioRemote.autoplay = true;
          document.body.appendChild(audioRemote);
        }
        audioRemote.srcObject = stream;
      }
    </script>

  {% endif %}

  <!-- –ü–ª–µ–π–µ—Ä—ã –¥–ª—è –∞—É–¥–∏–æ -->
  <audio id="localAudio" autoplay muted></audio>
  <audio id="remoteAudio" autoplay></audio>
</body>
</html>
