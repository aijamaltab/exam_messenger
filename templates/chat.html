<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Messenger Aijamal</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}" />
  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
  <script src="{{ url_for('static', filename='sip-0.21.2.min.js') }}"></script>
  <style>
    body, html {
      margin: 0; padding: 0; height: 100%; font-family: Arial, sans-serif;
      background: #f0f0f0;
    }
    .container {
      display: flex; height: 100vh;
    }
    .sidebar {
      width: 250px; background: #222; color: white; padding: 10px; box-sizing: border-box;
      display: flex; flex-direction: column;
    }
    .sidebar h2 {
      margin-top: 10px; margin-bottom: 10px;
    }
    .user-list {
      list-style: none; padding: 0; margin: 0; flex-grow: 1; overflow-y: auto;
    }
    .user-item {
      background: #333; margin-bottom: 8px; padding: 8px; border-radius: 4px; cursor: pointer;
      display: flex; justify-content: space-between; align-items: center;
    }
    .user-item:hover {
      background: #444;
    }
    .user-item strong {
      font-weight: bold;
    }
    .user-item small {
      display: block; font-size: 0.75em; color: #aaa;
    }
    .call-user-btn {
      background: #0a84ff; border: none; color: white; border-radius: 4px; padding: 4px 8px;
      cursor: pointer;
    }
    .call-user-btn:disabled {
      background: #555; cursor: default;
    }
    .chat {
      flex-grow: 1; display: flex; flex-direction: column; background: white;
      border-left: 1px solid #ccc;
    }
    .chat-header {
      padding: 10px; border-bottom: 1px solid #ccc; background: #eee;
    }
    #chat-box {
      flex-grow: 1; padding: 10px; overflow-y: auto;
      background: #fafafa;
    }
    .msg {
      margin-bottom: 10px; padding: 6px 12px; border-radius: 12px; max-width: 70%;
      word-wrap: break-word;
      display: inline-block;
      clear: both;
    }
    .msg-me {
      background: #0a84ff; color: white; float: right;
    }
    .msg-other {
      background: #ddd; color: black; float: left;
    }
    .msg small {
      display: block; font-size: 0.65em; margin-top: 4px; opacity: 0.7;
    }
    .chat-controls {
      padding: 10px; border-top: 1px solid #ccc; background: #eee;
      display: flex; gap: 6px;
    }
    #messageInput {
      flex-grow: 1; padding: 8px; border: 1px solid #ccc; border-radius: 4px;
      font-size: 1em;
    }
    .chat-controls button {
      background: #0a84ff; color: white; border: none; border-radius: 4px; padding: 0 16px;
      cursor: pointer; font-size: 1.2em;
    }
    #endCallBtn {
      background: #ff3b30;
    }
  </style>
</head>
<body>
{% if session.get('user_id') %}
<div class="container">
  <div class="sidebar">
    <form action="{{ url_for('logout') }}" method="GET">
      <button type="submit">Logout</button>
    </form>
    <h2>Users</h2>
    <ul id="users" class="user-list">
      {% for user in users %}
      <li class="user-item" data-id="{{ user[0] }}">
        <div>
          <strong>{{ user[1] }}</strong><br>
          <small>{{ user[2] }}</small>
        </div>
        <button class="call-user-btn">üìû</button>
      </li>
      {% endfor %}
    </ul>
  </div>
  <div class="chat">
    <div class="chat-header">
      <h3 id="chat-with">Select a user</h3>
    </div>
    <div id="chat-box" class="chat-box"></div>
    <div class="chat-controls">
      <input type="text" id="messageInput" placeholder="Enter a message" autocomplete="off" />
      <button onclick="sendMessage()">‚û§</button>
      <button id="endCallBtn" onclick="endCall()" style="display:none;">‚ùå End Call</button>
    </div>
  </div>
</div>

<audio id="localAudio" autoplay muted></audio>
<audio id="remoteAudio" autoplay></audio>

<script>
  const socket = io();
  const ICE_SERVERS = [{ urls: 'stun:stun.l.google.com:19302' }];
  const localUserId = "{{ session['user_id'] }}";
  const peerConnections = new Map();
  const pendingCandidates = {};
  let localStream = null;
  let selectedUserId = null;

  socket.on('connect', () => {
    console.log('‚úî Socket connected:', socket.id);
    socket.emit('register', { user_id: localUserId });
  });

  document.addEventListener('DOMContentLoaded', async () => {
    localStream = await getLocalStream();
    attachLocalStream(localStream);

    document.querySelectorAll('.user-item').forEach(item => {
      const targetId = item.dataset.id;
      const btn = item.querySelector('.call-user-btn');
      if (targetId === localUserId) btn.disabled = true;

      // –í—ã–±–æ—Ä –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è —á–∞—Ç–∞
      item.addEventListener('click', () => {
        selectedUserId = targetId;
        document.getElementById('chat-with').textContent = 'Chat with ' + item.querySelector('strong').textContent;
        loadMessages(selectedUserId);
      });

      // –ö–Ω–æ–ø–∫–∞ –∑–≤–æ–Ω–∫–∞
      btn.addEventListener('click', e => {
        e.stopPropagation(); // –Ω–µ —Å—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å –Ω–∞ —Å–æ–±—ã—Ç–∏–µ –≤—ã–±–æ—Ä–∞ —á–∞—Ç–∞
        startCall(targetId);
      });
    });

    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—Ö–æ–¥—è—â–∏—Ö –∑–≤–æ–Ω–∫–æ–≤ –∏ —Å–∏–≥–Ω–∞–ª–æ–≤ WebRTC
    socket.on('call-made', async ({ from, offer }) => {
      if (peerConnections.has(from)) {
        console.warn('–£–∂–µ –µ—Å—Ç—å —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å', from);
        return;
      }
      const pc = createPeerConnection(from);
      peerConnections.set(from, pc);
      await pc.setRemoteDescription(new RTCSessionDescription(offer));
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      socket.emit('make-answer', { to: from, answer });

      if (pendingCandidates[from]) {
        for (const candidate of pendingCandidates[from]) {
          await pc.addIceCandidate(new RTCIceCandidate(candidate));
        }
        delete pendingCandidates[from];
      }

      document.getElementById('endCallBtn').style.display = 'inline-block';
    });

    socket.on('answer-made', async ({ from, answer }) => {
      const pc = peerConnections.get(from);
      if (pc) await pc.setRemoteDescription(new RTCSessionDescription(answer));
    });

    socket.on('ice-candidate', async ({ from, candidate }) => {
      const pc = peerConnections.get(from);
      if (pc) {
        await pc.addIceCandidate(new RTCIceCandidate(candidate));
      } else {
        pendingCandidates[from] = pendingCandidates[from] || [];
        pendingCandidates[from].push(candidate);
      }
    });

    // –ù–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
    socket.on('new_message', data => {
      const { from_user_id, to_user_id } = data;
      if ((from_user_id == selectedUserId && to_user_id == localUserId) ||
          (from_user_id == localUserId && to_user_id == selectedUserId)) {
        loadMessages(selectedUserId);
      }
    });
  });

  async function startCall(to) {
    if (!localStream) {
      localStream = await getLocalStream();
      attachLocalStream(localStream);
    }

    if (peerConnections.has(to)) {
      alert('–£–∂–µ –µ—Å—Ç—å –∑–≤–æ–Ω–æ–∫ —Å —ç—Ç–∏–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º');
      return;
    }

    const pc = createPeerConnection(to);
    peerConnections.set(to, pc);
    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    socket.emit('call-user', { to, offer });

    document.getElementById('endCallBtn').style.display = 'inline-block';
  }

  function createPeerConnection(peerId) {
    const pc = new RTCPeerConnection({ iceServers: ICE_SERVERS });
    if(localStream) localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
    pc.onicecandidate = event => {
      if (event.candidate) {
        socket.emit('ice-candidate', { to: peerId, candidate: event.candidate });
      }
    };
    pc.ontrack = event => attachRemoteStream(event.streams[0]);
    pc.onconnectionstatechange = () => {
      if (pc.connectionState === "disconnected" || pc.connectionState === "failed" || pc.connectionState === "closed") {
        peerConnections.delete(peerId);
        document.getElementById('endCallBtn').style.display = 'none';
        removeRemoteAudio();
      }
    };
    return pc;
  }

  async function getLocalStream() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      return stream;
    } catch (err) {
      alert('–†–∞–∑—Ä–µ—à–∏—Ç–µ –¥–æ—Å—Ç—É–ø –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É');
      throw err;
    }
  }

  function attachLocalStream(stream) {
    let audio = document.getElementById('localAudio');
    if (!audio) {
      audio = document.createElement('audio');
      audio.id = 'localAudio';
      audio.autoplay = true;
      audio.muted = true;
      document.body.appendChild(audio);
    }
    audio.srcObject = stream;
  }

  function attachRemoteStream(stream) {
    let audio = document.getElementById('remoteAudio');
    if (!audio) {
      audio = document.createElement('audio');
      audio.id = 'remoteAudio';
      audio.autoplay = true;
      document.body.appendChild(audio);
    }
    audio.srcObject = stream;
    audio.play().catch(e => console.log('–û—à–∏–±–∫–∞ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è:', e));
  }

  function removeRemoteAudio() {
    const remoteAudio = document.getElementById('remoteAudio');
    if (remoteAudio) {
      remoteAudio.pause();
      remoteAudio.srcObject = null;
    }
  }

  // –ó–∞–≥—Ä—É–∑–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π –∏–∑ API
  function loadMessages(userId) {
    fetch(`/messages/${userId}`)
      .then(res => res.json())
      .then(data => {
        const box = document.getElementById('chat-box');
        box.innerHTML = '';
        data.forEach(msg => {
          const div = document.createElement('div');
          div.className = msg.from_me ? 'msg msg-me' : 'msg msg-other';
          div.innerHTML = `<span>${escapeHtml(msg.message)}</span><small>${msg.timestamp}</small>`;
          box.appendChild(div);
        });
        box.scrollTop = box.scrollHeight;
      });
  }

  // –û—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –Ω–∞ —Å–µ—Ä–≤–µ—Ä
  function sendMessage() {
    const input = document.getElementById('messageInput');
    const message = input.value.trim();
    if (!message || !selectedUserId) return;

    fetch('/send', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ to_user_id: selectedUserId, message })
    })
    .then(res => res.json())
    .then(() => {
      input.value = '';
      loadMessages(selectedUserId);
    });
  }

  function endCall() {
    // –û—Ç–∫–ª—é—á–∞–µ–º –≤—Å–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
    peerConnections.forEach((pc, peerId) => {
      try {
        pc.getSenders().forEach(sender => pc.removeTrack(sender));
      } catch {}
      pc.close();
      peerConnections.delete(peerId);
    });

    // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ª–æ–∫–∞–ª—å–Ω—ã–π –ø–æ—Ç–æ–∫
    if (localStream) {
      localStream.getTracks().forEach(track => track.stop());
      localStream = null;
    }

    removeRemoteAudio();

    // –°–∫—Ä—ã–≤–∞–µ–º –∫–Ω–æ–ø–∫—É –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –∑–≤–æ–Ω–∫–∞
    document.getElementById('endCallBtn').style.display = 'none';

    console.log('–ó–≤–æ–Ω–æ–∫ –∑–∞–≤–µ—Ä—à—ë–Ω');
  }

  // ======= JsSIP SIP –∞–∫–∫–∞—É–Ω—Ç =======
  const sipConfig = {
    sockets: [ new JsSIP.WebSocketInterface('wss://sip2sip.info:7443') ],
    uri: 'sip:sellinx@sip2sip.info', // –∑–∞–º–µ–Ω–∏—Ç–µ –Ω–∞ –≤–∞—à SIP URI
    password: '—Ç–≤–æ–π_–ø–∞—Ä–æ–ª—å',         // –∑–∞–º–µ–Ω–∏—Ç–µ –Ω–∞ –≤–∞—à –ø–∞—Ä–æ–ª—å
    session_timers: false,
  };

  const ua = new JsSIP.UA(sipConfig);

  ua.start();

  ua.on('registered', () => console.log('SIP –∞–∫–∫–∞—É–Ω—Ç –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω'));
  ua.on('registrationFailed', e => console.error('–û—à–∏–±–∫–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ SIP:', e.cause));
  ua.on('newRTCSession', e => {
    console.log('–ù–æ–≤–∞—è SIP —Å–µ—Å—Å–∏—è:', e);
    // –ú–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –ª–æ–≥–∏–∫—É –¥–ª—è –≤—Ö–æ–¥—è—â–∏—Ö –∑–≤–æ–Ω–∫–æ–≤ SIP
  });

  // –ü—Ä–æ—Å—Ç–∞—è –∑–∞—â–∏—Ç–∞ –æ—Ç XSS
  function escapeHtml(text) {
    const map = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#039;'
    };
    return text.replace(/[&<>"']/g, m => map[m]);
  }
</script>
{% endif %}
</body>
</html>
