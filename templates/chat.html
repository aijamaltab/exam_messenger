<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Messenger Aijamal</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
</head>
<body>
{% if session.get('user_id') %}
<div class="container">
  <div class="sidebar">
    <form action="{{ url_for('logout') }}" method="GET">
      <button type="submit">Logout</button>
    </form>
    <h2>Users</h2>
    <ul id="users" class="user-list">
      {% for user in users %}
      <li class="user-item" data-id="{{ user[0] }}">
        <strong>{{ user[1] }}</strong><br>
        <small>{{ user[2] }}</small>
        <button class="call-user-btn">üìû</button>
      </li>
      {% endfor %}
    </ul>
  </div>
  <div class="chat">
    <div class="chat-header">
      <h3 id="chat-with">Select a user</h3>
    </div>
    <div id="chat-box" class="chat-box"></div>
    <div class="chat-controls">
      <input type="text" id="messageInput" placeholder="Enter a message">
      <button onclick="sendMessage()">‚û§</button>
      <button id="endCallBtn" onclick="endCall()" style="display:none;">‚ùå End Call</button>
    </div>
  </div>
</div>

<script>
  const socket = io();
  const ICE_SERVERS = [{ urls: 'stun:stun.l.google.com:19302' }];
  const localUserId = "{{ session['user_id'] }}";
  const peerConnections = new Map();
  const pendingCandidates = {};
  let localStream = null;
  let selectedUserId = null;

  socket.on('connect', () => {
    console.log('‚úî Socket connected:', socket.id);
    socket.emit('register', { user_id: localUserId });
  });

  document.addEventListener('DOMContentLoaded', async () => {
    localStream = await getLocalStream();
    attachLocalStream(localStream);

    document.querySelectorAll('.user-item').forEach(item => {
      const targetId = item.dataset.id;
      const btn = item.querySelector('.call-user-btn');
      if (targetId === localUserId) btn.disabled = true;

      // üëâ –í—ã–±–æ—Ä –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
      item.addEventListener('click', () => {
        selectedUserId = targetId;
        document.getElementById('chat-with').textContent = 'Chat with ' + item.querySelector('strong').textContent;
        loadMessages(selectedUserId);
      });

      btn.addEventListener('click', () => startCall(targetId));
    });

    // ========== –í–∏–¥–µ–æ–∑–≤–æ–Ω–∫–∏ ==========
    socket.on('call-made', async ({ from, offer }) => {
      const pc = createPeerConnection(from);
      peerConnections.set(from, pc);
      await pc.setRemoteDescription(new RTCSessionDescription(offer));
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      socket.emit('make-answer', { to: from, answer });
      if (pendingCandidates[from]) {
        for (const candidate of pendingCandidates[from]) {
          await pc.addIceCandidate(new RTCIceCandidate(candidate));
        }
        delete pendingCandidates[from];
      }
    });

    socket.on('answer-made', async ({ from, answer }) => {
      const pc = peerConnections.get(from);
      if (pc) await pc.setRemoteDescription(new RTCSessionDescription(answer));
    });

    socket.on('ice-candidate', async ({ from, candidate }) => {
      const pc = peerConnections.get(from);
      if (pc) {
        await pc.addIceCandidate(new RTCIceCandidate(candidate));
      } else {
        pendingCandidates[from] = pendingCandidates[from] || [];
        pendingCandidates[from].push(candidate);
      }
    });

    // ========== –°–æ–æ–±—â–µ–Ω–∏—è ==========
    socket.on('new_message', data => {
      const { from_user_id, to_user_id } = data;
      if ((from_user_id == selectedUserId && to_user_id == localUserId) ||
          (from_user_id == localUserId && to_user_id == selectedUserId)) {
        loadMessages(selectedUserId);
      }
    });
  });

  async function startCall(to) {
    if (!localStream) {
      localStream = await getLocalStream();
      attachLocalStream(localStream);
    }
    
    const pc = createPeerConnection(to);
    peerConnections.set(to, pc);
    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    socket.emit('call-user', { to, offer });
  
    document.getElementById('endCallBtn').style.display = 'inline-block'; // –ø–æ–∫–∞–∑–∞—Ç—å –∫–Ω–æ–ø–∫—É –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è
  }



  function createPeerConnection(peerId) {
    const pc = new RTCPeerConnection({ iceServers: ICE_SERVERS });
    localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
    pc.onicecandidate = event => {
      if (event.candidate) {
        socket.emit('ice-candidate', { to: peerId, candidate: event.candidate });
      }
    };
    pc.ontrack = event => attachRemoteStream(event.streams[0]);
    return pc;
  }

  async function getLocalStream() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      return stream;
    } catch (err) {
      alert('–†–∞–∑—Ä–µ—à–∏—Ç–µ –¥–æ—Å—Ç—É–ø –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É');
      throw err;
    }
  }

  function attachLocalStream(stream) {
    let audio = document.getElementById('localAudio');
    if (!audio) {
      audio = document.createElement('audio');
      audio.id = 'localAudio';
      audio.autoplay = true;
      audio.muted = true;
      document.body.appendChild(audio);
    }
    audio.srcObject = stream;
  }

  function attachRemoteStream(stream) {
    let audio = document.getElementById('remoteAudio');
    if (!audio) {
      audio = document.createElement('audio');
      audio.id = 'remoteAudio';
      audio.autoplay = true;
      document.body.appendChild(audio);
    }
    audio.srcObject = stream;
    audio.play().catch(e => console.log('–û—à–∏–±–∫–∞ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è:', e));
  }

  // ========== –ß–ê–¢ ==========

  function loadMessages(userId) {
    fetch(`/messages/${userId}`)
      .then(res => res.json())
      .then(data => {
        const box = document.getElementById('chat-box');
        box.innerHTML = '';
        data.forEach(msg => {
          const div = document.createElement('div');
          div.className = msg.from_me ? 'msg msg-me' : 'msg msg-other';
          div.innerHTML = `<span>${msg.message}</span><small>${msg.timestamp}</small>`;
          box.appendChild(div);
        });
        box.scrollTop = box.scrollHeight;
      });
  }

  function sendMessage() {
    const input = document.getElementById('messageInput');
    const message = input.value.trim();
    if (!message || !selectedUserId) return;

    fetch('/send', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ to_user_id: selectedUserId, message })
    })
    .then(res => res.json())
    .then(() => {
      input.value = '';
    });
  }
  function endCall() {
  // –û—Ç–∫–ª—é—á–∞–µ–º –≤—Å–µ peerConnections
  peerConnections.forEach((pc, peerId) => {
    pc.getSenders().forEach(sender => {
      try {
        pc.removeTrack(sender);
      } catch (e) {
        console.warn('–û—à–∏–±–∫–∞ removeTrack:', e);
      }
    });
    pc.close();
    peerConnections.delete(peerId);
  });

  // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ª–æ–∫–∞–ª—å–Ω—ã–π –ø–æ—Ç–æ–∫
  if (localStream) {
    localStream.getTracks().forEach(track => track.stop());
    localStream = null;
  }

  // –û—á–∏—â–∞–µ–º –∞—É–¥–∏–æ-—ç–ª–µ–º–µ–Ω—Ç—ã
  const remoteAudio = document.getElementById('remoteAudio');
  if (remoteAudio) {
    remoteAudio.pause();
    remoteAudio.srcObject = null;
  }

  const localAudio = document.getElementById('localAudio');
  if (localAudio) {
    localAudio.pause();
    localAudio.srcObject = null;
  }

  // –°–∫—Ä—ã–≤–∞–µ–º –∫–Ω–æ–ø–∫—É –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –∑–≤–æ–Ω–∫–∞
  document.getElementById('endCallBtn').style.display = 'none';

  console.log('–ó–≤–æ–Ω–æ–∫ –∑–∞–≤–µ—Ä—à—ë–Ω');
}

</script>





<audio id="localAudio" autoplay muted></audio>
<audio id="remoteAudio" autoplay></audio>
{% endif %}
</body>
</html>
